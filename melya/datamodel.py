# Melya Framework for Google App Engine
# (c) 2011 Amir Shimoni
# Melya may be freely distributed under the MIT license.
import google.appengine.ext.db as db
from utils import getGitBlobHash, getStrSortableHexNum

class DB_ConfigData(db.Expando): pass

class DB_User(db.Model):
    """
    Let GAE pick the key id, and use that as the user id.
    """
    dateAdded = db.DateTimeProperty(auto_now_add=True)
    name = db.StringProperty()

class DB_UserLoginAssoc(db.Model):
    """
    User login associations, e.g. google login/facebook/twitter...
    the key name is 'g'+(google user id) for google login, 'f'+fbid, 't'+twitter id
    """
    uid = db.IntegerProperty() # key id of DB_User - no need for reference, since it's always DB_User's id

class DB_UserData(db.Expando):
    """
    parent is DB_User
    key_name is the info type, e.g. 'emails', etc...
    all properties are dynamic
    """
    pass

class DB_Domains(db.Expando):
    """
    GAE picks an id
    """
    name = db.StringProperty() # the name that is passed to the client
    regex = db.StringProperty()
    defaultTitle = db.StringProperty()
    order = db.FloatProperty()
    dateUpdated = db.DateTimeProperty(auto_now=True)

    #_compiledRegex = None

class DB_Pages(db.Expando):
    domainName = db.StringProperty() # corresponds to the domain's name (key_name)
    regex = db.StringProperty()
    fileName = db.StringProperty()
    order = db.FloatProperty()
    dateUpdated = db.DateTimeProperty(auto_now=True)
    flags = db.StringProperty() # special flags (comma seperated) like 'jinja' and 'cache'
    #_compiledRegex = None
    #_parsedFlagList = frozenset of flags

class DB_FileContent(db.Model):
    """ The key_name is the hash (github sha1) hash of the data - getGitBlobHash()
    """
    date_added = db.DateTimeProperty(auto_now_add=True)
    data = db.BlobProperty()

    @classmethod
    def CheckAndSave(cls, data):
        """Return True,key if saved, otherwise False, Key if already exists."""
        new_hash = getGitBlobHash(data)
        theDataKey = cls.all(keys_only=True).filter('__key__ =', db.Key.from_path(u'DB_FileContent', new_hash)).get()
        if theDataKey: return False, theDataKey
        theDataKey = cls(key_name = new_hash, data = db.Blob(data)).put()
        return True, theDataKey

    @classmethod
    def GetEmptyKey(cls):
        return db.Key.from_path(u'DB_FileContent', u'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391')


class DB_FileVersion(db.Model):
    """
    parent is DB_FileContent - so we can search with key_only to get the data
    key_name is the version (same as version below)
    """
    filename = db.StringProperty() # the file name with path 'js/myfile.coffee' - shouldn't contain ':'
    version = db.IntegerProperty() # the version generated by DB_JV_AtomicCounter
    dateAdded = db.DateTimeProperty(auto_now_add=True)
    generatedFrom = db.SelfReferenceProperty()
    uid = db.IntegerProperty() # the id of DB_User
    tags = db.StringListProperty() # tags should not be '_'
    # the special index - we do this, so we don't have to have the user create an index entry in index.yaml
    index = db.StringListProperty()
    # otherwise we would need this index:
    #- kind: DB_FileVersion
    #  properties:
    #  - name: filename
    #  - name: tags
    #  - name: version
    #    direction: desc


    def updateIndex(self): # Make sure to call this before saving if not using db.put or db.put_async
        # could use more than base 16, but don't care that much.
        self.index = ['%s:%s:%s' % (self.filename, x, getStrSortableHexNum(self.version)) for x in self.tags]

    def put(self, **kwargs):
        self.updateIndex()
        super(DB_FileVersion, self).put(**kwargs)

    @classmethod
    def getMostRecent(cls, filename, tag, keys_only=False):
        max1 = '%s:%s~' % (filename, tag)
        min1 = '%s:%s:' % (filename, tag)
        return  cls.all(keys_only=keys_only).filter('index >', min1).filter('index <', max1).order('-index').get()
        #return cls.all(keys_only=keys_only).filter('filename =', fn).filter('tags =', 'a').order('-version').get()

    @classmethod
    def getSpecificVersion(cls, filename, tag, version, keys_only=False):
        indexKey = '%s:%s:%s' % (filename, tag, getStrSortableHexNum(version))
        return cls.all(keys_only=keys_only).filter('index =', indexKey).get()
        #return cls.all(keys_only=keys_only).filter('filename =', filename).filter('tags =',tag).filter('version =', version).get()



class DB_FileBuild(db.Model):
    """
    This is the generated version of the file used for caching (server and client) purposes
    The key_name is the filename (from DB_FileVersion) + ':' + version tag ('' or 'a' for now) + ':' + cacheVerNum
       except for the latest version which doesn't have the last cacheVerNum (and doesn't have the data either)
    """
    data = db.BlobProperty() # the actual generated file
    hashVal = db.StringProperty() # the getGitBlobHash() of data
    cacheVerNum = db.IntegerProperty() # the earliest version number (fver) that had this hashVal
    fileVerCheckTime = db.IntegerProperty() # the latest version (fver) at which we checked to see if data changed.
    dateGenerated = db.DateTimeProperty(auto_now_add=True)


class DB_JV_AtomicCounter(db.Model):
    """
    An atomic counter for file versions.  It's slow, but it's hardly used, so it's ok.
    key_name is counterName
    currently using "fver" and "processCfgVer"
    """
    counter = db.IntegerProperty()

    @classmethod
    def GetNextCounter(cls, counterName):
        def tx():
            temp = cls.get_by_key_name(counterName)
            if not temp: temp = cls(key_name=counterName, counter=0)
            temp.counter += 1
            temp.put()
            return temp.counter
        return db.run_in_transaction_custom_retries(10, tx)

    @classmethod
    def GetMostRecentlyReturnedCounterValue(cls, counterName):
        temp = cls.get_by_key_name(counterName)
        if not temp: return cls.GetNextCounter(counterName) # execute once if it's the first time
        return temp.counter


